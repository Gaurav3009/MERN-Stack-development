React Js:
    React is a javascript library used to create single page frontend application.
    React is fast beacuse it uses virtual DOM.
    also we can make reusable components in React.
    Data flow is uni-directional from parent to child.
    It uses JSX to write code simpler.

Angular is a framework and javascript is a library.
Framework gives us full power to deploy the app but library doesn't have that power.

Single Page Application : React we don't have referesh and we can direct route and change the content. 
It means we can change the contents on the same page using some conditions.
This is why it is fast.

Component : It is the independent piece of code which we can implemennt anywhere.
There are two types of components.
1> Functional Components 
2> Class Based Components


Virtual DOM : It is the programming technique where a virtual copy of DOM is kept. 
In DOM if a chnage happens in particular place whole page is rendered again.
Virtual DOM is the virtual copy of the actual DOM in the memory and if any change made to it creates  another 
virtual DOM with the changes and then compares using BFS and when changes found then the cahnges is applied
and then the previous DOM is deleted.

Reconciliation --> this live syncing is called Reconciliation

JSX: It is teh way of writing HTML inside javascript.

npm : is a package where we can access the codes pre written 

state,   Props
State--> Properties of a compomnent -> changes -> componenets will re render.
Props --> Properties when we want to transfer some properties from parent to child we use props

Functional Components : 
        just like a function is javascript and props can be received as a parameter inside the function 
        function(props){
            return (<div>
            .....</div>);
        }
        props is an object inside the child and we can access the property using .

        Hooks : in built functions in react to be used in functional components.

        Life Cycle methods : function   There is a class based component.
        Mounting Updated Unmounting.


state : (behaviour) --> state has some values which defines the behaviour of that component.
props : (properties) --> given by parent to its child.

If any of these changes the page rerenders.
rerenders -> update based on change. if(stateand props change)

Components : (parts) --> portions of the website.

Types of Componenets:
    1> Class Based components :
            Inheritance : Acquiring a child parent relation.
            JavaScript class: 
            class Rectangle{
                constructor(length, breadth){
                    this.length = length;
                    this.breadth = breadth;
                }
                static RectangleSide(){
                    console.log("Has four side");
                }
                properties(){
                    console.log("opposite side have same lengths");
                }
            }
            class Square extends Rectangle{
                constructor(length){
                    super();
                }
            }
            In class components we have LifeCycle methods : Life cycle is the method of component class
                class Footer extends Components{
                    constructor(props){
                        super(props);
                        this.state = {
                            key : val,
                            k2 : val2
                        }; // tocreate a state
                    }
                    this.props.someValue;
                    To change state we use : this.setState({key : val});
                }
                Forbidden : never change props in child
                    never update state in rerender because infinite loop will be triggered.
                    render(){
                        this.setState(...);
                    }

                    LifeCycle method : 
                    Born : mounting --> mounted to DOM
                    infant-teenage-adult-oldage --> Updating (state props changes and updating occurs)
                    death : unmounting --> Removed from DOM

                    1> Mounting : 
                        a> Constructor : called one time (during creation)
                        b> static getDerivedStateFromProps(Props, State) : 
                                getDerivedStateFromProps(Props, State){
                                    return {key : props.val};
                                } // when we change the state or props it will be called implictly and change the props and state after the first time.
                        c> render() : 
                        d> componentDidMount() : called one time -->Component is mounted to DOM now would you want to do anything (API calls which happens only ones eg. login)
                    
                    2> Updating : 
                        a> static getDerivedStateFrom()
                        b> ShouldComponentUpdate(nextProps){
                            if(this.props.val == this.nextProps.val){
                                return false;
                            }
                        }
                        c> render()
                        d> getSnapshotBeforeUpdate() : used rarely 
                            takes screenshot of current state before painting the changes to the DOM.
                        e> componentDidUpdate(){
                            API calls
                        }

    2> Functional components :
            Earlier they were stateless in nature (they were weak therefore)
            Hooks : in built function to replicate functionalities of lifeCycle method.
            Rules : 
            1> Sould be only implemented in react functional components.
            2> Should be used on top level of function not inside nested structure(if for etc).

            function Footer(props){
                return(JSX);
            }
            Hooks : 
            1> useState : gives functionalities of a state.
            const[name, setName] = useState(" //initial_value");
            name : variable , setName : function to change
            setName("Harshal");

            sideEffect : Did someting which results in something which is not the expected behaviour.
            manipulate something which doesn't belong to its scope will cause a side effect.
            example :
                var a = 5;
                function abc(){
                    a = 7;
                }
                web API creates the side effects.
                Types of side effects : 
                a> with cleanup :
                    setInterval() <--> clearInterval()
                b> without cleanup : 
                    API call
                
            useEffect : 
                useEffect(()=>{
                    return ()=>{
                        clearInterval();
                    }
                }, x); 
                * can be called after every update.
                    if x is nothing then it will be called everytime,
                    if x is [] (empty array) then called once like componentDidMount()
                    if x is [val] only gets triggered if val changes
            
            for component will unmount 
                useEffect(()=>{
                    return ()=>{
                        clearInterval();
                    }
                }, x); 

        Handelling error 
        // Available only in class based componnents
        1> getDerivedStateFromError(){
            return {hasError  :true};
        }
        2> componenetsDidCatch(error){
            lof(error);
        }

Controlled and Uncontrolled components : 
Controlled componenets means react can change
Uncontrolled behaviour react cannot controll -- >> controlled directly by DOM
    In react we can create a componenent using useRef :
    useRef --> If it change, It doesn't trigger a rerender.

componenetDidUpdate using useEffect ? 


Prop drilling : Penetration 
passing of prop from parent to childeren so that it can be used at the place where it was needed to be deliver.
State Manangemen tool : Redux(Most Popular one), Flus, Clearx // used to avoid prop drilling
var data = { // global object // object literal the way of defining
    k1 : v1,
    k2 : v2,
    k3 : v3
};
const store = new clearx(data); // new instance of the object

** Observer Pattern : // clearx folow this pattern even redux 
    There is one subject and multiple observer and whenever the state changes in the subject then it is reflected among all the observer.
    // It is also called as the fan-out effect. 
    example : notification (Polling --> Pinging someone in frequent interval.)
// How to link the instances to the global object?
store.({
    key1, key2, key3
}).link(this); // any of this key values changes it will be updated in the new instances 
and the componenet will rerender.

# Context: 
    It is the way available in functional components which is used to avoid prop drilling. 
    Context has three phases: 
    1> Creation Phase
        We can simply create a context using this syntax :-
            const quoteContext = React.createContext();
    2> Wrapping up Phase 
        We have a provider to provide and useContext for consumption.
        Now we are going to create a function which will act as a provider.
            export function quoteContextProvider({childeren}){
                const [name, setName] = useState("");
                const [age, setAge] = useState(0);
                let value = {
                    name,
                    setName, 
                    age,
                    setAge
                }
                return <quoteContext.Provider value = {value}>
                {childeren}
                </quoteContext.provider>
            }
            <quoteContext.Provider>
                <quote/>
            </quoteContext.Provider>
    3> Consumption Phase
        Wherever we want to use we can destructure these.
        const {name, setName} = useContext(quoteContext);

# Material UI / Ant-Design : 
    Bootstrap gives us the UI componenets to to use in our website.
    Similarly Mtaerial UI and Ant-Design also give the UI componenets to be use in React.

* How a website works?
    When we search "amazoan.in" on internet it contacts with the DNS server and search for the IP address of the amazon.in and return it to the browswer.
    Now the browser makes request to that IP address associated with the site and the server does does some processing and delivers a particular response.
    Now the server response consists of data whic is nothing just a (HTML CSS AND JavaScript)

API : (Application Programming Interface) --> prer-written code which is used to perform some action
--> function opened to the internet provided we know the IP of the machine and the name of the API.
Currently we have a twi tier architecture : 
Client Server Model : 
        Client <----> Server

HTTP : Hypertext Transfer Protocol (Protocol --> set of rules)
    It is teh set of rules using which the communication occuers between two devices using Internet.

REST API :  (REST --> Representational State Transfer)
    REST is an architectural style of representing something.

RESTful API : REST architectural constraints.
    1> Uniform Interface : doesn't discriminate depending on the device from where the request was raised. (same response)
    2> Statelessness : Store session data 
    3> Cachable : storing the data in Cache memory.
    Storing the request response data in the Cache : when next time we do teh same request we will be getting the response from the cache memory rather than performing another request. (same response)
    4> Client Sever Architecture : 
    5> Layred Architecture :
    6> Code on Demand : Server sends code to execute by client.

Operations : 
    CRUD : Create Read Update Delete

# Axios & FetchAPI : 
    They are the ways to make HTTP calls.
    They are promise based.

# Status code : 
    1xx --> information
    2xx --> success
    3xx --> redirection
    4xx --> client side error
    5xx --> server sie error
    We send data to server as "data" in axios & as "body" in fetch.
    axios().then().catch()
    fetch(url).then().catch()
    // goes nside the catch if there is an network error in fetch
